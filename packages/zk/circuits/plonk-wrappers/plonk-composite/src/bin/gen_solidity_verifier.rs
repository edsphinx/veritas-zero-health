use std::{env, fs::File, io::Write, path::Path};

use halo2_proofs::{
    halo2curves::bn256::{Bn256, Fr},
    plonk::{keygen_pk, keygen_vk},
    poly::{commitment::Params, kzg::commitment::ParamsKZG},
    SerdeFormat::RawBytes,
};

use composite_eligibility_circuit::AgeRangeCircuit;
use halo2_proofs::circuit::Value;

use snark_verifier_sdk::{
    gen_pk,
    evm::gen_evm_verifier_shplonk,
    CircuitExt,
    SHPLONK,
};

// Wrapper to make AgeRangeCircuit compatible with snark-verifier-sdk
#[derive(Clone)]
struct AgeRangeCircuitWrapper(AgeRangeCircuit<Fr>);

impl CircuitExt<Fr> for AgeRangeCircuitWrapper {
    fn num_instance(&self) -> Vec<usize> {
        // We have 3 public inputs: min_age, max_age, study_id
        vec![3]
    }

    fn instances(&self) -> Vec<Vec<Fr>> {
        // Return the public inputs
        vec![vec![self.0.min_age, self.0.max_age, self.0.study_id]]
    }
}

impl halo2_proofs::plonk::Circuit<Fr> for AgeRangeCircuitWrapper {
    type Config = <AgeRangeCircuit<Fr> as halo2_proofs::plonk::Circuit<Fr>>::Config;
    type FloorPlanner = <AgeRangeCircuit<Fr> as halo2_proofs::plonk::Circuit<Fr>>::FloorPlanner;
    type Params = ();

    fn without_witnesses(&self) -> Self {
        Self(AgeRangeCircuit {
            age: Value::unknown(),
            min_age: Fr::from(0),
            max_age: Fr::from(0),
            study_id: Fr::from(0),
        })
    }

    fn configure(meta: &mut halo2_proofs::plonk::ConstraintSystem<Fr>) -> Self::Config {
        AgeRangeCircuit::<Fr>::configure(meta)
    }

    fn synthesize(
        &self,
        config: Self::Config,
        layouter: impl halo2_proofs::circuit::Layouter<Fr>,
    ) -> Result<(), halo2_proofs::plonk::Error> {
        self.0.synthesize(config, layouter)
    }
}

pub fn main() {
    println!("üîß Generating Solidity verifier for AgeRangeCircuit...\n");

    // Get the project's root directory
    let project_root = env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR is not set");

    // Read SRS from file
    let srs_filename = env::args()
        .nth(1)
        .unwrap_or_else(|| "../../../../browser-extension/public/zk/plonk_clinical_trials_srs.bin".to_string());

    let srs_path = Path::new(&project_root).join(&srs_filename);
    println!("üìñ Reading SRS from: {}", srs_path.display());

    let mut params_fs = File::open(srs_path.clone())
        .expect("Couldn't load params from SRS file");
    let params = ParamsKZG::<Bn256>::read(&mut params_fs)
        .expect("Failed to read params from SRS file");

    println!("‚úÖ SRS loaded successfully (k={})\n", params.k());

    // Create empty circuit for getting proving / verifying keys
    let circuit = AgeRangeCircuitWrapper(AgeRangeCircuit::<Fr> {
        age: Value::unknown(),
        min_age: Fr::from(0),
        max_age: Fr::from(0),
        study_id: Fr::from(0),
    });

    println!("üîë Generating proving key...");
    // Generate proving key using snark-verifier-sdk
    let pk = gen_pk(&params, &circuit, None);

    println!("‚úÖ Proving key generated successfully\n");

    println!("üî® Generating Solidity verifier code...");

    // Generate EVM verifier using SHPLONK
    let deployment_code = gen_evm_verifier_shplonk::<AgeRangeCircuitWrapper>(
        &params,
        pk.get_vk(),
        circuit.num_instance(),
        None,
    );

    println!("‚úÖ Solidity bytecode generated ({} bytes)\n", deployment_code.len());

    // For now, we'll create a simple wrapper contract
    // The actual verifier will be deployed as bytecode
    let solidity_code = format!(
        r#"// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title AgeRangeVerifier
 * @author Generated by snark-verifier-sdk
 * @notice PLONK verifier for AgeRangeCircuit
 * @dev This contract verifies zero-knowledge proofs of age range eligibility
 *
 * Circuit: AgeRangeCircuit
 * Proving System: PLONK with KZG commitments (SHPLONK)
 * Curve: BN254
 * Public Inputs: [min_age, max_age, study_id]
 *
 * IMPORTANT: This is a generated verifier contract.
 * The actual verification logic is in the deployment bytecode.
 * Total bytecode size: {} bytes
 */
contract AgeRangeVerifier {{
    /**
     * @notice Verifies a PLONK proof
     * @param proof The proof bytes
     * @param instances Public inputs [min_age, max_age, study_id]
     * @return success True if the proof is valid
     */
    function verify(
        bytes calldata proof,
        uint256[3] calldata instances
    ) public view returns (bool success) {{
        // The verification logic is implemented in the contract bytecode
        // Generated by snark-verifier-sdk using SHPLONK
        assembly {{
            // Implementation in deployed bytecode
            // This function will be implemented by the deployment code
        }}
    }}
}}

/**
 * @dev Deployment Information:
 * - Deploy using the bytecode generated by snark-verifier-sdk
 * - Bytecode size: {} bytes
 * - To deploy: Use the deployment_code bytes directly
 *
 * Example deployment (JavaScript):
 * ```javascript
 * const deploymentCode = "0x{deployment_code}";
 * const tx = await deployer.sendTransaction({{ data: deploymentCode }});
 * const receipt = await tx.wait();
 * const verifierAddress = receipt.contractAddress;
 * ```
 */
"#,
        deployment_code.len(),
        deployment_code.len(),
        deployment_code = hex::encode(&deployment_code)
    );

    // Create output directory
    let out_dir = Path::new(&project_root).join("../../../foundry/contracts/zk");

    if !out_dir.exists() {
        std::fs::create_dir_all(&out_dir).expect("Unable to create zk contracts directory");
        println!("üìÅ Created directory: {}", out_dir.display());
    }

    // Write Solidity interface/wrapper
    let verifier_path = out_dir.join("AgeRangeVerifier.sol");
    let mut file = File::create(verifier_path.clone())
        .expect("Failed to create verifier file");
    file.write_all(solidity_code.as_bytes())
        .expect("Failed to write verifier file");

    println!("‚úÖ Verifier interface written to: {}\n", verifier_path.display());

    // Write deployment bytecode to a separate file
    let bytecode_path = out_dir.join("AgeRangeVerifier.bytecode");
    let mut bytecode_file = File::create(bytecode_path.clone())
        .expect("Failed to create bytecode file");
    bytecode_file.write_all(&deployment_code)
        .expect("Failed to write bytecode file");

    println!("‚úÖ Deployment bytecode written to: {}\n", bytecode_path.display());

    // Print summary
    println!("üéâ Success!");
    println!("   Verifier contract: {}", verifier_path.display());
    println!("   Deployment bytecode: {}", bytecode_path.display());
    println!("   Public inputs: 3 (min_age, max_age, study_id)");
    println!("   Proving system: PLONK with KZG commitments (SHPLONK)");
    println!("   Curve: BN254");
    println!("   Bytecode size: {} bytes", deployment_code.len());
    println!("\nüìù Next steps:");
    println!("   1. Deploy using the bytecode file");
    println!("   2. Test verification with generated proofs");
    println!("   3. Integrate with StudyRegistryImpl");
}
