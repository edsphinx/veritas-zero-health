import {
  readdirSync,
  statSync,
  readFileSync,
  existsSync,
  mkdirSync,
  writeFileSync,
} from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { format } from "prettier";

const __dirname = dirname(fileURLToPath(import.meta.url));

const generatedContractComment = `
/**
 * This file is autogenerated by Scaffold-ETH.
 * You should not edit it manually or your changes might be overwritten.
 */`;

function getDirectories(path) {
  if (!existsSync(path)) {
    return [];
  }

  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isDirectory();
  });
}

function getFiles(path) {
  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isFile();
  });
}

function parseTransactionAndReceiptRun(filePath) {
  try {
    const content = readFileSync(filePath, "utf8");
    const broadcastData = JSON.parse(content);
    return {
      transactions: broadcastData.transactions || [],
      receipts: broadcastData.receipts || [],
    };
  } catch (error) {
    console.warn(`Warning: Could not parse ${filePath}:`, error.message);
    return [];
  }
}

function getDeploymentHistory(broadcastPath) {
  const files = getFiles(broadcastPath);
  const deploymentHistory = new Map();

  // Sort files to process them in chronological order
  const runFiles = files
    .filter(
      (file) =>
        file.startsWith("run-") &&
        file.endsWith(".json") &&
        !file.includes("run-latest")
    )
    .sort((a, b) => {
      // Extract run numbers and compare them
      const runA = parseInt(a.match(/run-(\d+)/)?.[1] || "0");
      const runB = parseInt(b.match(/run-(\d+)/)?.[1] || "0");
      return runA - runB;
    });

  for (const file of runFiles) {
    const { transactions, receipts } = parseTransactionAndReceiptRun(
      join(broadcastPath, file)
    );

    for (const tx of transactions) {
      if (tx.transactionType === "CREATE") {
        // Store or update contract deployment info
        deploymentHistory.set(tx.contractAddress, {
          contractName: tx.contractName,
          address: tx.contractAddress,
          deploymentFile: file,
          transaction: tx,
          receipt: receipts.find((r) => r.transactionHash === tx.hash),
        });
      }
    }
  }

  return Array.from(deploymentHistory.values());
}

function getArtifactOfContract(contractName) {
  // Special case: Groth16Verifier is in EligibilityCodeVerifier.sol
  const solFileName = contractName === 'Groth16Verifier'
    ? 'EligibilityCodeVerifier'
    : contractName;

  const current_path_to_artifacts = join(
    __dirname,
    "..",
    `out/${solFileName}.sol`
  );

  if (!existsSync(current_path_to_artifacts)) {
    console.warn(`‚ö†Ô∏è  Artifact directory not found for ${contractName} (looking in ${solFileName}.sol)`);
    return null;
  }

  // Try to find the JSON file - it might have a different name than the contract
  try {
    // First try the expected name
    const expectedPath = `${current_path_to_artifacts}/${contractName}.json`;
    if (existsSync(expectedPath)) {
      return JSON.parse(readFileSync(expectedPath));
    }

    // If not found, look for any JSON file in the directory
    const files = readdirSync(current_path_to_artifacts);
    const jsonFile = files.find(f => f.endsWith('.json'));

    if (jsonFile) {
      console.log(`üìù Using ${jsonFile} for ${contractName}`);
      return JSON.parse(readFileSync(`${current_path_to_artifacts}/${jsonFile}`));
    }

    console.warn(`‚ö†Ô∏è  No JSON artifact found for ${contractName}`);
    return null;
  } catch (error) {
    console.warn(`‚ö†Ô∏è  Error reading artifact for ${contractName}:`, error.message);
    return null;
  }
}

function getInheritedFromContracts(artifact) {
  let inheritedFromContracts = [];
  if (artifact?.ast) {
    for (const astNode of artifact.ast.nodes) {
      if (astNode.nodeType == "ContractDefinition") {
        if (astNode.baseContracts.length > 0) {
          inheritedFromContracts = astNode.baseContracts.map(
            ({ baseName }) => baseName.name
          );
        }
      }
    }
  }
  return inheritedFromContracts;
}

function getInheritedFunctions(mainArtifact) {
  const inheritedFromContracts = getInheritedFromContracts(mainArtifact);
  const inheritedFunctions = {};
  for (const inheritanceContractName of inheritedFromContracts) {
    const artifact = getArtifactOfContract(inheritanceContractName);
    if (artifact) {
      const {
        abi,
        ast: { absolutePath },
      } = artifact;
      for (const abiEntry of abi) {
        if (abiEntry.type == "function") {
          inheritedFunctions[abiEntry.name] = absolutePath;
        }
      }
    }
  }
  return inheritedFunctions;
}

function processAllDeployments(broadcastPath) {
  // Reverse mapping: Solidity contract name ‚Üí deployment JSON key
  const reverseMapping = {
    'MockUSDC': 'MockUSDC',
    'MockHumanPassport': 'humanPassport',
    'MedicalProviderRegistry': 'providerRegistry',
    'HealthIdentitySBT': 'healthIdentity',
    'PatientAccountFactory': 'accountFactory',
    'StudyParticipationSBT': 'participationSBT',
    'StudyEnrollmentData': 'enrollmentData',
    'Groth16Verifier': 'eligibilityVerifier',
    'StudyRegistry': 'studyRegistry',
    'ResearchFundingEscrow': 'researchEscrow',
    'CommitmentVaultFactory': 'vaultFactory',
    'StudyAccessNFT': 'studyAccessNFT',
    'ComplianceScore': 'complianceScore',
  };

  const scriptFolders = getDirectories(broadcastPath);
  const allDeployments = new Map();

  scriptFolders.forEach((scriptFolder) => {
    const scriptPath = join(broadcastPath, scriptFolder);
    const chainFolders = getDirectories(scriptPath);

    chainFolders.forEach((chainId) => {
      const chainPath = join(scriptPath, chainId);
      const deploymentHistory = getDeploymentHistory(chainPath);

      deploymentHistory.forEach((deployment) => {
        const timestamp = parseInt(
          deployment.deploymentFile.match(/run-(\d+)/)?.[1] || "0"
        );
        const key = `${chainId}-${deployment.contractName}`;

        // Only update if this deployment is newer
        if (
          !allDeployments.has(key) ||
          timestamp > allDeployments.get(key).timestamp
        ) {
          allDeployments.set(key, {
            ...deployment,
            timestamp,
            chainId,
            deploymentScript: scriptFolder,
            deployedOnBlock: deployment?.receipt?.blockNumber,
          });
        }
      });
    });
  });

  const allContracts = {};

  allDeployments.forEach((deployment) => {
    const { chainId, contractName } = deployment;
    const artifact = getArtifactOfContract(contractName);

    if (artifact) {
      if (!allContracts[chainId]) {
        allContracts[chainId] = {};
      }

      // Use the mapped name from deployments JSON for consistency
      const mappedName = reverseMapping[contractName] || contractName;

      allContracts[chainId][mappedName] = {
        address: deployment.address,
        abi: artifact.abi,
        inheritedFunctions: getInheritedFunctions(artifact),
        deploymentFile: deployment.deploymentFile,
        deploymentScript: deployment.deploymentScript,
        deployedOnBlock: deployment?.deployedOnBlock && Number(BigInt(deployment.deployedOnBlock)),
      };
    } else {
      console.warn(`‚ö†Ô∏è  Skipping ${contractName} on chain ${chainId} - artifact not found`);
    }
  });

  return allContracts;
}

async function main() {
  const current_path_to_broadcast = join(__dirname, "..", "broadcast");
  const current_path_to_deployments = join(__dirname, "..", "deployments");

  const Deploymentchains = getFiles(current_path_to_deployments);
  const deployments = {};

  // Load existing deployments from deployments directory
  Deploymentchains.forEach((chain) => {
    if (!chain.endsWith(".json")) return;
    chain = chain.slice(0, -5);
    var deploymentObject = JSON.parse(
      readFileSync(`${current_path_to_deployments}/${chain}.json`)
    );
    deployments[chain] = deploymentObject;
  });

  let allGeneratedContracts = {};

  // First, process deployments from broadcast folder (if exists)
  if (existsSync(current_path_to_broadcast)) {
    allGeneratedContracts = processAllDeployments(current_path_to_broadcast);
  }

  // Then, process and merge deployments from deployments folder
  // This allows us to add deployments that are only in deployments/ folder (like Celo networks)
  Object.entries(deployments).forEach(([fileName, deploymentData]) => {
    const chainId = deploymentData.chainId || fileName.split('_')[0];

    if (!allGeneratedContracts[chainId]) {
      allGeneratedContracts[chainId] = {};
    }

    // Map deployment key names to actual contract names
    const contractNameMapping = {
      'MockUSDC': 'MockUSDC',
      'humanPassport': 'MockHumanPassport',
      'providerRegistry': 'MedicalProviderRegistry',
      'healthIdentity': 'HealthIdentitySBT',
      'accountFactory': 'PatientAccountFactory',
      'participationSBT': 'StudyParticipationSBT',
      'enrollmentData': 'StudyEnrollmentData',
      'eligibilityVerifier': 'Groth16Verifier',
      'studyRegistry': 'StudyRegistry',
      'researchEscrow': 'ResearchFundingEscrow',
      'vaultFactory': 'CommitmentVaultFactory',
      'studyAccessNFT': 'StudyAccessNFT',
      'complianceScore': 'ComplianceScore',
    };

    // Map contract addresses to their names
    Object.entries(deploymentData).forEach(([key, value]) => {
      if (key === 'chainId' || key === 'network' || key === 'timestamp' || key === 'deployer') return;

      // Key is the contract name (e.g., "studyRegistry", "ageVerifier")
      // Value is the address
      const contractName = key;
      const address = value;

      // Skip if this contract is already in allGeneratedContracts for this chain
      if (allGeneratedContracts[chainId][contractName]) {
        return; // Already processed from broadcast folder
      }

      // Try to find the artifact - try mapping first, then common patterns
      const possibleNames = [
        contractNameMapping[contractName],
        contractName,
        contractName.charAt(0).toUpperCase() + contractName.slice(1),
        contractName.replace(/([A-Z])/g, '_$1').replace(/^_/, ''),
      ].filter(Boolean);

      let artifact = null;
      let foundName = null;
      for (const name of possibleNames) {
        artifact = getArtifactOfContract(name);
        if (artifact) {
          foundName = name;
          break;
        }
      }

      if (artifact && foundName) {
        console.log(`‚úÖ Mapped ${contractName} ‚Üí ${foundName} for chain ${chainId}`);
      }

      if (artifact) {
        allGeneratedContracts[chainId][contractName] = {
          address: address,
          abi: artifact.abi,
          inheritedFunctions: getInheritedFunctions(artifact),
        };
      }
    });
  });

  const NEXTJS_TARGET_DIR = "../nextjs/contracts/";

  // Ensure target directories exist
  if (!existsSync(NEXTJS_TARGET_DIR)) {
    mkdirSync(NEXTJS_TARGET_DIR, { recursive: true });
  }

  // Generate the deployedContracts content
  const fileContent = Object.entries(allGeneratedContracts).reduce(
    (content, [chainId, chainConfig]) => {
      const cleanedChainConfig = Object.fromEntries(
        Object.entries(chainConfig).map(([contractName, contractData]) => {
          const { deploymentFile, deploymentScript, ...rest } = contractData;
          return [contractName, rest];
        })
      );
      return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(
        cleanedChainConfig,
        null,
        2
      )},`;
    },
    ""
  );

  // Write the files
  const fileTemplate = (importPath) => `
    ${generatedContractComment}
    import { GenericContractsDeclaration } from "${importPath}";

    const deployedContracts = {${fileContent}} as const;

    export default deployedContracts satisfies GenericContractsDeclaration;
  `;

  writeFileSync(
    `${NEXTJS_TARGET_DIR}deployedContracts.ts`,
    await format(fileTemplate("./types"), {
      parser: "typescript",
    })
  );

  console.log(
    `üìù Updated TypeScript contract definition file on ${NEXTJS_TARGET_DIR}deployedContracts.ts`
  );
}

try {
  main();
} catch (error) {
  console.error("Error:", error);
  process.exitCode = 1;
}
